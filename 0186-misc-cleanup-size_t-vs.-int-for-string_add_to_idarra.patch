From 2f497b152a3d968addb7bc34d1a1fbdf6963bea8 Mon Sep 17 00:00:00 2001
From: Karel Zak <kzak@redhat.com>
Date: Tue, 6 Aug 2019 11:19:13 +0200
Subject: [PATCH] misc: cleanup size_t vs. int for string_add_to_idarray()

The newly backported utils use size_t, but the original code is still
based on int to count output columns. Let's use int everywhere..

Addresses: https://bugzilla.redhat.com/show_bug.cgi?id=1712768
Signed-off-by: Karel Zak <kzak@redhat.com>
---
 login-utils/lslogins.c |  8 ++++----
 sys-utils/lsipc.c      | 20 ++++++++++----------
 sys-utils/lsmem.c      | 11 +++++------
 sys-utils/lsns.c       | 10 +++++-----
 sys-utils/wdctl.c      |  7 ++++---
 sys-utils/zramctl.c    |  8 ++++----
 6 files changed, 32 insertions(+), 32 deletions(-)

diff --git a/login-utils/lslogins.c b/login-utils/lslogins.c
index 041053625..33d4777e5 100644
--- a/login-utils/lslogins.c
+++ b/login-utils/lslogins.c
@@ -438,8 +438,8 @@ static struct utmp *get_last_wtmp(struct lslogins_control *ctl, const char *user
 
 static int require_wtmp(void)
 {
-	size_t i;
-	for (i = 0; i < (size_t) ncolumns; i++)
+	int i;
+	for (i = 0; i < ncolumns; i++)
 		if (is_wtmp_col(columns[i]))
 			return 1;
 	return 0;
@@ -447,8 +447,8 @@ static int require_wtmp(void)
 
 static int require_btmp(void)
 {
-	size_t i;
-	for (i = 0; i < (size_t) ncolumns; i++)
+	int i;
+	for (i = 0; i < ncolumns; i++)
 		if (is_btmp_col(columns[i]))
 			return 1;
 	return 0;
diff --git a/sys-utils/lsipc.c b/sys-utils/lsipc.c
index 0be9d9128..1c2c4b294 100644
--- a/sys-utils/lsipc.c
+++ b/sys-utils/lsipc.c
@@ -194,7 +194,7 @@ static const struct lsipc_coldesc coldescs[] =
  * column twice. That's enough, dynamically allocated array of the columns is
  * unnecessary overkill and over-engineering in this case */
 static int columns[ARRAY_SIZE(coldescs) * 2];
-static size_t ncolumns;
+static int ncolumns;
 
 static inline size_t err_columns_index(size_t arysz, size_t idx)
 {
@@ -358,7 +358,7 @@ static struct libscols_table *new_table(struct lsipc_control *ctl)
 static struct libscols_table *setup_table(struct lsipc_control *ctl)
 {
 	struct libscols_table *table = new_table(ctl);
-	size_t n;
+	int n;
 
 	for (n = 0; n < ncolumns; n++) {
 		int flags = coldescs[columns[n]].flag;
@@ -473,7 +473,7 @@ static void global_set_data(struct libscols_table *tb, const char *resource,
 			    const char *desc, uintmax_t used, uintmax_t limit, int usage)
 {
 	struct libscols_line *ln;
-	size_t n;
+	int n;
 
 	ln = scols_table_new_line(tb, NULL);
 	if (!ln)
@@ -545,7 +545,7 @@ static void do_sem(int id, struct lsipc_control *ctl, struct libscols_table *tb)
 		return;
 	}
 	for (semdsp = semds;  semdsp->next != NULL || id > -1; semdsp = semdsp->next) {
-		size_t n;
+		int n;
 		ln = scols_table_new_line(tb, NULL);
 
 		for (n = 0; n < ncolumns; n++) {
@@ -732,7 +732,7 @@ static void do_msg(int id, struct lsipc_control *ctl, struct libscols_table *tb)
 	}
 
 	for (msgdsp = msgds; msgdsp->next != NULL || id > -1 ; msgdsp = msgdsp->next) {
-		size_t n;
+		int n;
 		ln = scols_table_new_line(tb, NULL);
 
 		/* no need to call getpwuid() for the same user */
@@ -888,7 +888,7 @@ static void do_shm(int id, struct lsipc_control *ctl, struct libscols_table *tb)
 	}
 
 	for (shmdsp = shmds; shmdsp->next != NULL || id > -1 ; shmdsp = shmdsp->next) {
-		size_t n;
+		int n;
 		ln = scols_table_new_line(tb, NULL);
 		if (!ln)
 			err_oom();
@@ -1073,7 +1073,7 @@ int main(int argc, char *argv[])
 {
 	int opt, msg = 0, sem = 0, shm = 0, id = -1;
 	int show_time = 0, show_creat = 0, global = 0;
-	size_t i;
+	int i;
 	struct lsipc_control *ctl = xcalloc(1, sizeof(struct lsipc_control));
 	static struct libscols_table *tb;
 	char *outarg = NULL;
@@ -1248,7 +1248,7 @@ int main(int argc, char *argv[])
 
 	if (ctl->outmode == OUT_PRETTY && !(optarg || show_creat || show_time)) {
 		/* all columns for lsipc --<RESOURCE> --id <ID> */
-		for (ncolumns = 0, i = 0; i < ARRAY_SIZE(coldescs); i++)
+		for (ncolumns = 0, i = 0; i < (int) ARRAY_SIZE(coldescs); i++)
 			 columns[ncolumns++] = i;
 	} else {
 		if (show_creat) {
@@ -1264,7 +1264,7 @@ int main(int argc, char *argv[])
 		}
 		if (shm && show_time) {
 			/* keep "COMMAND" as last column */
-			size_t cmd = columns[ncolumns - 1] == COL_COMMAND;
+			int cmd = columns[ncolumns - 1] == COL_COMMAND;
 
 			if (cmd)
 				ncolumns--;
@@ -1280,7 +1280,7 @@ int main(int argc, char *argv[])
 	}
 
 	if (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),
-					 (int *) &ncolumns, column_name_to_id) < 0)
+					&ncolumns, column_name_to_id) < 0)
 		return EXIT_FAILURE;
 
 	tb = setup_table(ctl);
diff --git a/sys-utils/lsmem.c b/sys-utils/lsmem.c
index aaf7374fc..4f682691d 100644
--- a/sys-utils/lsmem.c
+++ b/sys-utils/lsmem.c
@@ -138,7 +138,7 @@ static struct coldesc coldescs[] = {
  * column twice. That's enough, dynamically allocated array of the columns is
  * unnecessary overkill and over-engineering in this case */
 static int columns[ARRAY_SIZE(coldescs) * 2];
-static size_t ncolumns;
+static int ncolumns;
 
 static inline size_t err_columns_index(size_t arysz, size_t idx)
 {
@@ -183,7 +183,7 @@ static int column_name_to_id(const char *name, size_t namesz)
 static inline int get_column_id(int num)
 {
 	assert(num >= 0);
-	assert((size_t) num < ncolumns);
+	assert(num < ncolumns);
 	assert(columns[num] < (int) ARRAY_SIZE(coldescs));
 
 	return columns[num];
@@ -230,7 +230,7 @@ static void set_split_policy(struct lsmem *l, int cols[], size_t ncols)
 
 static void add_scols_line(struct lsmem *lsmem, struct memory_block *blk)
 {
-	size_t i;
+	int i;
 	struct libscols_line *line;
 
 	line = scols_table_new_line(lsmem->table, NULL);
@@ -523,8 +523,7 @@ int main(int argc, char **argv)
 		}, *lsmem = &_lsmem;
 
 	const char *outarg = NULL, *splitarg = NULL;
-	int c;
-	size_t i;
+	int c, i;
 
 	enum {
 		LSMEM_OPT_SUMARRY = CHAR_MAX + 1
@@ -640,7 +639,7 @@ int main(int argc, char **argv)
 	}
 
 	if (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),
-					 (int *) &ncolumns, column_name_to_id) < 0)
+					&ncolumns, column_name_to_id) < 0)
 		return EXIT_FAILURE;
 
 	/*
diff --git a/sys-utils/lsns.c b/sys-utils/lsns.c
index d32756508..74f04dc12 100644
--- a/sys-utils/lsns.c
+++ b/sys-utils/lsns.c
@@ -95,7 +95,7 @@ static const struct colinfo infos[] = {
 };
 
 static int columns[ARRAY_SIZE(infos) * 2];
-static size_t ncolumns;
+static int ncolumns;
 
 enum {
 	LSNS_ID_MNT = 0,
@@ -193,7 +193,7 @@ static int column_name_to_id(const char *name, size_t namesz)
 static inline int get_column_id(int num)
 {
 	assert(num >= 0);
-	assert((size_t) num < ncolumns);
+	assert(num < ncolumns);
 	assert(columns[num] < (int) ARRAY_SIZE(infos));
 
 	return columns[num];
@@ -444,7 +444,7 @@ static int read_namespaces(struct lsns *ls)
 static void add_scols_line(struct lsns *ls, struct libscols_table *table,
 			   struct lsns_namespace *ns, struct lsns_process *proc)
 {
-	size_t i;
+	int i;
 	struct libscols_line *line;
 
 	assert(ns);
@@ -504,7 +504,7 @@ static void add_scols_line(struct lsns *ls, struct libscols_table *table,
 static struct libscols_table *init_scols_table(struct lsns *ls)
 {
 	struct libscols_table *tab;
-	size_t i;
+	int i;
 
 	tab = scols_new_table();
 	if (!tab) {
@@ -745,7 +745,7 @@ int main(int argc, char *argv[])
 	}
 
 	if (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),
-					(int *) &ncolumns, column_name_to_id) < 0)
+					&ncolumns, column_name_to_id) < 0)
 		return EXIT_FAILURE;
 
 	scols_init_debug(0);
diff --git a/sys-utils/wdctl.c b/sys-utils/wdctl.c
index 24ec770fb..5e996d0ba 100644
--- a/sys-utils/wdctl.c
+++ b/sys-utils/wdctl.c
@@ -238,7 +238,7 @@ static void add_flag_line(struct tt *tt, struct wdinfo *wd, const struct wdflag
 
 static int show_flags(struct wdinfo *wd, int tt_flags, uint32_t wanted)
 {
-	size_t i;
+	int i;
 	int rc = -1;
 	struct tt *tt;
 	uint32_t flags;
@@ -251,7 +251,7 @@ static int show_flags(struct wdinfo *wd, int tt_flags, uint32_t wanted)
 	}
 
 	/* define columns */
-	for (i = 0; i < (size_t) ncolumns; i++) {
+	for (i = 0; i < ncolumns; i++) {
 		struct colinfo *col = get_column_info(i);
 
 		if (!tt_define_column(tt, col->name, col->whint, col->flags)) {
@@ -264,7 +264,7 @@ static int show_flags(struct wdinfo *wd, int tt_flags, uint32_t wanted)
 	 * -- one line for each supported flag (option)	 */
 	flags = wd->ident.options;
 
-	for (i = 0; i < ARRAY_SIZE(wdflags); i++) {
+	for (i = 0; i < (int) ARRAY_SIZE(wdflags); i++) {
 		if (wanted && !(wanted & wdflags[i].flag))
 			; /* ignore */
 		else if (flags & wdflags[i].flag)
@@ -513,6 +513,7 @@ int main(int argc, char *argv[])
 			return EXIT_SUCCESS;
 		case 'h':
 			usage(stdout);
+			/* fallthrough */
 		case 'F':
 			noflags = 1;
 			break;
diff --git a/sys-utils/zramctl.c b/sys-utils/zramctl.c
index c3112d68a..3a558d150 100644
--- a/sys-utils/zramctl.c
+++ b/sys-utils/zramctl.c
@@ -392,7 +392,7 @@ static void fill_table_row(struct libscols_table *tb, struct zram *z)
 {
 	static struct libscols_line *ln;
 	struct sysfs_cxt *sysfs;
-	size_t i;
+	int i;
 	uint64_t num;
 
 	assert(tb);
@@ -408,7 +408,7 @@ static void fill_table_row(struct libscols_table *tb, struct zram *z)
 	if (!ln)
 		err(EXIT_FAILURE, _("failed to initialize output line"));
 
-	for (i = 0; i < (size_t) ncolumns; i++) {
+	for (i = 0; i < ncolumns; i++) {
 		char *str = NULL;
 
 		switch (get_column_id(i)) {
@@ -479,7 +479,7 @@ static void fill_table_row(struct libscols_table *tb, struct zram *z)
 static void status(struct zram *z)
 {
 	struct libscols_table *tb;
-	size_t i;
+	int i;
 
 	scols_init_debug(0);
 
@@ -490,7 +490,7 @@ static void status(struct zram *z)
 	scols_table_enable_raw(tb, raw);
 	scols_table_enable_noheadings(tb, no_headings);
 
-	for (i = 0; i < (size_t) ncolumns; i++) {
+	for (i = 0; i < ncolumns; i++) {
 		const struct colinfo *col = get_column_info(i);
 
 		if (!scols_table_new_column(tb, col->name, col->whint, col->flags))
-- 
2.21.0

